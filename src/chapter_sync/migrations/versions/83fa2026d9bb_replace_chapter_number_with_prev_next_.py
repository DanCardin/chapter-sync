"""Replace chapter number with prev/next chapter URLs

Revision ID: 83fa2026d9bb
Revises: 63139caea00e
Create Date: 2025-09-26 15:15:27.173187

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '83fa2026d9bb'
down_revision: Union[str, None] = '63139caea00e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('chapter', schema=None) as batch_op:
        batch_op.add_column(sa.Column('previous_chapter_url', sa.Text(), nullable=True))
        batch_op.add_column(sa.Column('next_chapter_url', sa.Text(), nullable=True))
    
    # Data migration: populate previous_chapter_url and next_chapter_url based on existing numbers
    connection = op.get_bind()
    
    # Get all chapters ordered by series_id and number
    result = connection.execute(sa.text("""
        SELECT id, series_id, number, url 
        FROM chapter 
        ORDER BY series_id, number
    """))
    
    chapters = list(result)
    
    # Build mapping of series_id -> list of (number, url, id) tuples
    series_chapters = {}
    for chapter in chapters:
        series_id = chapter.series_id
        if series_id not in series_chapters:
            series_chapters[series_id] = []
        series_chapters[series_id].append((chapter.number, chapter.url, chapter.id))
    
    # Update previous_chapter_url and next_chapter_url for each chapter
    for series_id, chapter_list in series_chapters.items():
        # Sort by number to ensure correct order
        chapter_list.sort(key=lambda x: x[0])
        
        for i, (number, url, chapter_id) in enumerate(chapter_list):
            previous_url = None
            next_url = None
            
            # Get previous chapter URL
            if i > 0:
                previous_url = chapter_list[i - 1][1]  # URL of previous chapter
            
            # Get next chapter URL
            if i < len(chapter_list) - 1:
                next_url = chapter_list[i + 1][1]  # URL of next chapter
            
            # Update the chapter with the URLs
            connection.execute(sa.text("""
                UPDATE chapter 
                SET previous_chapter_url = :prev_url, next_chapter_url = :next_url
                WHERE id = :chapter_id
            """), {
                'prev_url': previous_url,
                'next_url': next_url,
                'chapter_id': chapter_id
            })
    
    # Drop the constraint and column after data migration
    with op.batch_alter_table('chapter', schema=None) as batch_op:
        batch_op.drop_constraint('chapter_series_id_number_key', type_='unique')
        batch_op.create_unique_constraint(batch_op.f('chapter_series_id_url_key'), ['series_id', 'url'])
        batch_op.drop_column('number')

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    
    # Add the number column back first (nullable initially)
    with op.batch_alter_table('chapter', schema=None) as batch_op:
        batch_op.add_column(sa.Column('number', sa.INTEGER(), nullable=True))
    
    # Data migration: reconstruct chapter numbers from the chain
    connection = op.get_bind()
    
    # Get all chapters with their URLs
    result = connection.execute(sa.text("""
        SELECT id, series_id, url, previous_chapter_url, next_chapter_url 
        FROM chapter 
        ORDER BY series_id
    """))
    
    chapters = list(result)
    
    # Build mapping per series
    series_chapters = {}
    for chapter in chapters:
        series_id = chapter.series_id
        if series_id not in series_chapters:
            series_chapters[series_id] = []
        series_chapters[series_id].append(chapter)
    
    # For each series, rebuild the chapter numbers by following the chain
    for series_id, chapter_list in series_chapters.items():
        # Create URL to chapter mapping
        url_to_chapter = {c.url: c for c in chapter_list}
        
        # Find the first chapter (one without previous_chapter_url)
        first_chapter = None
        for chapter in chapter_list:
            if not chapter.previous_chapter_url:
                first_chapter = chapter
                break
        
        if first_chapter:
            # Follow the chain and assign numbers
            current = first_chapter
            number = 1
            visited = set()
            
            while current and current.url not in visited:
                visited.add(current.url)
                
                # Update the chapter with its number
                connection.execute(sa.text("""
                    UPDATE chapter 
                    SET number = :number
                    WHERE id = :chapter_id
                """), {
                    'number': number,
                    'chapter_id': current.id
                })
                
                # Move to next chapter
                if current.next_chapter_url and current.next_chapter_url in url_to_chapter:
                    current = url_to_chapter[current.next_chapter_url]
                    number += 1
                else:
                    break
        else:
            # Fallback: assign numbers based on creation order or ID
            sorted_chapters = sorted(chapter_list, key=lambda c: c.id)
            for i, chapter in enumerate(sorted_chapters):
                connection.execute(sa.text("""
                    UPDATE chapter 
                    SET number = :number
                    WHERE id = :chapter_id
                """), {
                    'number': i + 1,
                    'chapter_id': chapter.id
                })
    
    # Make number column non-nullable and restore constraints
    with op.batch_alter_table('chapter', schema=None) as batch_op:
        batch_op.alter_column('number', nullable=False)
        batch_op.drop_constraint(batch_op.f('chapter_series_id_url_key'), type_='unique')
        batch_op.create_unique_constraint('chapter_series_id_number_key', ['series_id', 'number'])
        batch_op.drop_column('next_chapter_url')
        batch_op.drop_column('previous_chapter_url')

    # ### end Alembic commands ###
